set nocompatible
call pathogen#infect()
filetype plugin indent on

let mapleader=","
let g:mapleader=","

if has("autocmd")
    "au BufWritePost .vimrc source $MYVIMRC
endif

nmap <silent> <Leader>ev :e $MYVIMRC<cr>
nmap <silent> <Leader>sv :so $MYVIMRC<cr>

set number
set numberwidth=5
set cursorline
set ruler
set mouse=a
set hidden
set showcmd
set showmode
set nolazyredraw
set wildmenu
set wildmode=longest,list
set laststatus=2
set cmdheight=2
set backspace=indent,eol,start
set whichwrap+=<,>,h,l,[,]
set report=0
set nostartofline
set background=light
command! W :w
set showtabline=2
set list
set listchars=tab:▸\ ,trail:·
set shellslash
set history=10000
set showmatch
set title
set visualbell
set mousehide
set synmaxcol=500

if has("autocmd")
    au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif
endif

set incsearch
set hls
set ignorecase
set smartcase
set wrapscan
nnoremap <silent> <CR> :nohlsearch<cr>
map Q gq
set autoindent
" set smartindent
set nowrap
set so=7
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
set nosmarttab
set nomodeline
if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
    if has("gui_macvim")
        set guifont=Inconsolata:h14
    else
        set guifont=Inconsolata\ 14
    endif
end
if has("gui_running")
    :set lines=100
    :set columns=171
    set go-=T
    set go-=L
    set go-=r
    color xoria256
else
    color desert
endif
:set t_Co=256
:set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)
:hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red

" Remap the tab key to do autocompletion or indentation depending on the
" context (from http://www.vim.org/tips/tip.php?tip_id=102)
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <tab> <c-r>=InsertTabWrapper()<cr>
inoremap <s-tab> <c-n>

augroup myfiletypes
    "clear old autocmds in group
    autocmd!
    "for ruby, autoindent with two spaces, always expand tabs
    autocmd BufRead,BufNewFile {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru}    set ft=ruby
    autocmd FileType ruby,haml,eruby,yaml,html,javascript,sass,cucumber set ai sw=2 sts=2 et
    autocmd FileType python set sw=4 sts=4 et
augroup END
set switchbuf=useopen
let macvim_hig_shift_movement = 1

function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

nnoremap <leader>' ""yls<c-r>={'"': "'", "'": '"'}[@"]<cr><esc>

"test"

map <leader>gr :topleft :split config/routes.rb<cr>
function! ShowRoutes()
    " Requires 'scratch' plugin
    :topleft 100 :split __Routes__
    " Make sure Vim doesn't write __Routes__ as a file
    :set buftype=nofile
    " Delete everything
    :normal 1GdG
    " Put routes output in buffer
    :0r! rake -s routes
    " Size window to number of lines (1 plus rake output length)
    :exec ":normal " . line("$") . "_ "
    " Move cursor to bottom
    :normal 1GG
    " Delete empty trailing line
    :normal dd
endfunction
map <leader>gR :call ShowRoutes()<cr>
nnoremap <leader><leader> <c-^>
set winwidth=84
" We have to have a winheight bigger than we want to set winminheight. But if
" we set winheight to be huge before winminheight, the winminheight set will
" fail.
set winheight=5
set winminheight=5
set winheight=999
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <c-n> :let &wh = (&wh == 999 ? 10 : 999)<CR><C-W>=
function! ShowColors()
    let num = 255
    while num >= 0
        exec 'hi col_'.num.' ctermbg='.num.' ctermfg=white'
        exec 'syn match col_'.num.' "ctermbg='.num.':...." containedIn=ALL'
        call append(0, 'ctermbg='.num.':....')
        let num = num - 1
    endwhile
endfunction

let g:CommandTMaxHeight=20
let g:syntastic_enable_signs=1
let g:syntastic_quiet_warnings=1

" Testing Functions
function! RunTests(filename)
    " Write the file and run tests for the given filename
    :w
    :silent !echo;echo;echo;echo;echo
    exec ":!bundle exec rspec " . a:filename
endfunction

function! SetTestFile()
    " Set the spec file that tests will be run for.
    let t:grb_test_file=@%
endfunction

function! RunTestFile(...)
    if a:0
        let command_suffix = a:1
    else
        let command_suffix = ""
    endif

    " Run the tests for the previously-marked file.
    let in_spec_file = match(expand("%"), '_spec.rb$') != -1
    if in_spec_file
        call SetTestFile()
    elseif !exists("t:grb_test_file")
        return
    end
    call RunTests(t:grb_test_file . command_suffix)
endfunction

function! RunNearestTest()
    let spec_line_number = line('.')
    call RunTestFile(":" . spec_line_number)
endfunction
map <leader>t :CommandTFlush<cr>\|:CommandT<cr>
" Run this file
map <leader>f :call RunTestFile()<cr>
" Run only the example under the cursor
map <leader>F :call RunNearestTest()<cr>
" Run all test files
map <leader>a :call RunTests('spec')<cr>

